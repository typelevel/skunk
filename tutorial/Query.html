<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Queries · Skunk</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content='docs'/>
<link rel="canonical" href="https://github.com/tpolecat/skunktutorial/Query.html"/>
<link href="https://fonts.googleapis.com/css?family=Roboto:100normal,100italic,300normal,300italic,400normal,400italic,500normal,500italic,700normal,700italic,900normal,900italicc" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/warnOldVersion.js"></script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/snippets.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="../css/page.css"/>

<!--
<link rel="shortcut icon" href="../images/favicon.ico" />
-->
</head>

<body>
<div class="off-canvas-wrapper">
<div class="off-canvas-wrapper-inner" data-off-canvas-wrapper>

<div class="off-canvas position-left" id="off-canvas-menu" data-off-canvas>
<nav class="off-canvas-nav">
<div class="nav-home">
<a href="../index.html" >
<span class="home-icon">⌂</span>Skunk
</a>
<div class="version-number">
0.2.3
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="../tutorial/Index.html" class="page">Tutorial</a>
  <ul>
    <li><a href="../tutorial/Setup.html" class="page">Setup</a></li>
    <li><a href="../tutorial/Query.html" class="active page">Queries</a></li>
    <li><a href="../tutorial/Command.html" class="page">Commands</a></li>
    <li><a href="../tutorial/Transactions.html" class="page">Transactions</a></li>
    <li><a href="../tutorial/Channels.html" class="page">Channels</a></li>
    <li><a href="../tutorial/Tracing.html" class="page">Tracing</a></li>
  </ul></li>
  <li><a href="../reference/Index.html" class="page">Reference</a>
  <ul>
    <li><a href="../reference/Sessions.html" class="page">Sessions</a></li>
    <li><a href="../reference/TwiddleLists.html" class="page">Twiddle Lists</a></li>
    <li><a href="../reference/Encoders.html" class="page">Encoders</a></li>
    <li><a href="../reference/Fragments.html" class="page">Fragments</a></li>
    <li><a href="../reference/Identifiers.html" class="page">Identifiers</a></li>
    <li><a href="../reference/Concurrency.html" class="page">Concurrency</a></li>
    <li><a href="../reference/SchemaTypes.html" class="page">Schema Types</a></li>
  </ul></li>
</ul>
</div>

</nav>
</div>

<div class="off-canvas-content" data-off-canvas-content>

<header class="site-header expanded row">
<div class="small-12 column">
<a href="#" class="off-canvas-toggle hide-for-medium" data-toggle="off-canvas-menu"><svg class="svg-icon svg-icon-menu" version="1.1" id="Menu" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve"> <path class="svg-icon-menu-path" fill="#53CDEC" d="M16.4,9H3.6C3.048,9,3,9.447,3,10c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,9.447,16.952,9,16.4,9z M16.4,13
H3.6C3.048,13,3,13.447,3,14c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,13.447,16.952,13,16.4,13z M3.6,7H16.4
C16.952,7,17,6.553,17,6c0-0.553-0.048-1-0.6-1H3.6C3.048,5,3,5.447,3,6C3,6.553,3.048,7,3.6,7z"/></svg>
</a>
<div class="title"><a href="../index.html">Skunk</a></div>

<!--
<a href="https://www.example.com" class="logo show-for-medium">logo</a>
-->
</div>
</header>

<div class="expanded row">

<div class="medium-3 large-2 show-for-medium column">
<nav class="site-nav">
<div class="nav-home">
<a href="../index.html" >
<span class="home-icon">⌂</span>Skunk
</a>
<div class="version-number">
0.2.3
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="../tutorial/Index.html" class="page">Tutorial</a>
  <ul>
    <li><a href="../tutorial/Setup.html" class="page">Setup</a></li>
    <li><a href="../tutorial/Query.html" class="active page">Queries</a></li>
    <li><a href="../tutorial/Command.html" class="page">Commands</a></li>
    <li><a href="../tutorial/Transactions.html" class="page">Transactions</a></li>
    <li><a href="../tutorial/Channels.html" class="page">Channels</a></li>
    <li><a href="../tutorial/Tracing.html" class="page">Tracing</a></li>
  </ul></li>
  <li><a href="../reference/Index.html" class="page">Reference</a>
  <ul>
    <li><a href="../reference/Sessions.html" class="page">Sessions</a></li>
    <li><a href="../reference/TwiddleLists.html" class="page">Twiddle Lists</a></li>
    <li><a href="../reference/Encoders.html" class="page">Encoders</a></li>
    <li><a href="../reference/Fragments.html" class="page">Fragments</a></li>
    <li><a href="../reference/Identifiers.html" class="page">Identifiers</a></li>
    <li><a href="../reference/Concurrency.html" class="page">Concurrency</a></li>
    <li><a href="../reference/SchemaTypes.html" class="page">Schema Types</a></li>
  </ul></li>
</ul>
</div>

</nav>
</div>

<div class="small-12 medium-9 large-10 column">
<section class="site-content">

<span id="version-warning"></span>

<div class="page-header row">
<div class="medium-12 show-for-medium column">
<div class="nav-breadcrumbs">
<ul>
  <li><a href="../index.html">Skunk</a></li>
  <li><a href="../tutorial/Index.html">Tutorial</a></li>
  <li>Queries</li>
</ul>
</div>
</div>
</div>

<div class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#queries" name="queries" class="anchor"><span class="anchor-link"></span></a>Queries</h1>
<p>This section explains how to construct and execute queries.</p><div class="callout note "><div class="callout-title">Definition</div>
<p>A <em>query</em> is a SQL statement that can return rows.</p></div>
<h2><a href="#single-column-query" name="single-column-query" class="anchor"><span class="anchor-link"></span></a>Single-Column Query</h2>
<p>First let&rsquo;s look at a query that selects a single column and decodes rows as Scala strings.</p>
<pre class="prettyprint"><code class="language-scala">val a: Query[Void, String] =
  sql&quot;SELECT name FROM country&quot;.query(varchar)
// a: Query[Void, String] = Query(
//   sql = &quot;SELECT name FROM country&quot;,
//   encoder = Codec(void),
//   decoder = Codec(varchar)
// )
</code></pre>
<p>Observe the following:</p>
<ul>
  <li>We are using the <a href="../reference/Fragments.html">sql interpolator</a> to construct a <a href="https://static.javadoc.io/org.tpolecat/skunk-core_2.12/0.2.3/skunk/Fragment.html" title="skunk.Fragment"><code>Fragment</code></a>, which we then turn into a <a href="https://static.javadoc.io/org.tpolecat/skunk-core_2.12/0.2.3/skunk/Query.html" title="skunk.Query"><code>Query</code></a> by calling the <code>query</code> method (fragments are also used to construct <a href="Command.html">Commands</a>).</li>
  <li>The argument to <code>query</code> is a value called <code>varchar</code>, which has type <code>Decoder[String]</code> and defines the read relationship between the Postgres type <code>varchar</code> and the Scala type <code>String</code>. The relationship between Postgres types and Scala types is summarized in the reference section <a href="../reference/SchemaTypes.html">Schema Types</a>.</li>
  <li>The first type argument for our <code>Query</code> type is <code>Void</code>, which means this query has no parameters. The second type argument is <code>String</code>, which means we expect rows to be decoded as <code>String</code> values (via our <code>varchar</code> decoder).</li>
</ul><div class="callout note "><div class="callout-title">Note</div>
<p>Query and Command types are usually inferrable, but specifying a type ensures that the chosen encoders and decoders are consistent with the expected input and output Scala types. For this reason (and for clarity) we will always use explicit type annotations in the documentation.</p></div>
<p>The query above is a <em>simple query</em>.</p><div class="callout note "><div class="callout-title">Definition</div>
<p>A <em>simple query</em> is a query with no parameters.</p></div>
<p>Postgres provides a <a href="https://www.postgresql.org/docs/10/protocol-flow.html#id-1.10.5.7.4">protocol</a> for execution of simple queries, returning all rows at once (Skunk returns them as a list). Such queries can be passed directly to <a href="https://static.javadoc.io/org.tpolecat/skunk-core_2.12/0.2.3/skunk/Session.html#execute" title="skunk.Session"><code>Session#execute</code></a>.</p>
<pre class="prettyprint"><code class="language-scala">// assume s: Session[IO]
s.execute(a) // IO[List[String]]
</code></pre>
<p><a href="https://static.javadoc.io/org.tpolecat/skunk-core_2.12/0.2.3/skunk/Session.html" title="skunk.Session"><code>Session</code></a> provides the following methods for direct execution of simple queries. See the Scaladoc for more information.</p>
<table>
  <thead>
    <tr>
      <th>Method </th>
      <th>Return Type </th>
      <th>Notes </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>execute</code> </td>
      <td><code>F[List[A]]</code> </td>
      <td>All results, as a list. </td>
    </tr>
    <tr>
      <td><code>option</code> </td>
      <td><code>F[Option[A]]</code> </td>
      <td>Zero or one result, otherwise an error is raised. </td>
    </tr>
    <tr>
      <td><code>unique</code> </td>
      <td><code>F[A]</code> </td>
      <td>Exactly one result, otherwise an error is raised. </td>
    </tr>
  </tbody>
</table>
<h2><a href="#multi-column-query" name="multi-column-query" class="anchor"><span class="anchor-link"></span></a>Multi-Column Query</h2>
<p>Our next example selects two columns.</p>
<pre class="prettyprint"><code class="language-scala">val b: Query[Void, String ~ Int] =
  sql&quot;SELECT name, population FROM country&quot;.query(varchar ~ int4)
// b: Query[Void, (String, Int)] = Query(
//   sql = &quot;SELECT name, population FROM country&quot;,
//   encoder = Codec(void),
//   decoder = Codec(varchar, int4)
// )
</code></pre>
<p>Observe that the argument to <code>query</code> is a pair of decoders conjoined with the <code>~</code> operator, yielding a <code>Decoder[String ~ Int]</code>. Executing this query will yield a <code>List[String ~ Int]</code>, which is an alias for <code>List[(String, Int)]</code>. See the section on <a href="../reference/TwiddleLists.html">twiddle lists</a> for more information on this mechanism.</p>
<h3><a href="#mapping-query-results" name="mapping-query-results" class="anchor"><span class="anchor-link"></span></a>Mapping Query Results</h3>
<p>Decoding into a twiddle list (i.e., nested pairs) isn&rsquo;t ideal, so let&rsquo;s define a <code>Country</code> data type. We can then call <code>map</code> on our query to adapt the row type.</p>
<pre class="prettyprint"><code class="language-scala">case class Country(name: String, population: Int)

val c: Query[Void, Country] =
  sql&quot;SELECT name, population FROM country&quot;
    .query(varchar ~ int4)                // (1)
    .map { case n ~ p =&gt; Country(n, p) }  // (2)
// c: Query[Void, Country] = Query(
//   sql = &quot;SELECT name, population FROM country&quot;,
//   encoder = Encoder(),
//   decoder = Decoder(varchar, int4)
// )
</code></pre>
<p>Observe the following:</p>
<ul>
  <li>At ① we request that rows be decoded by <code>varchar ~ int4</code> into Scala type <code>String ~ Int</code>.</li>
  <li>At ② we <code>map</code> to our <code>Country</code> data type, yielding a <code>Query[Void, Country]</code>.</li>
</ul>
<p>So that is one way to do it.</p>
<h3><a href="#mapping-decoder-results" name="mapping-decoder-results" class="anchor"><span class="anchor-link"></span></a>Mapping Decoder Results</h3>
<p>A more reusable way to do this is to define a <code>Decoder[Country]</code> based on the <code>varchar ~ int4</code> decoder. We can then decode directly into our <code>Country</code> data type.</p>
<pre class="prettyprint"><code class="language-scala">val country: Decoder[Country] =
  (varchar ~ int4).map { case (n, p) =&gt; Country(n, p) }     // (1)
// country: Decoder[Country] = Decoder(varchar, int4)     // (1)

val d: Query[Void, Country] =
  sql&quot;SELECT name, population FROM country&quot;.query(country)  // (2)
// d: Query[Void, Country] = Query(
//   sql = &quot;SELECT name, population FROM country&quot;,
//   encoder = Codec(void),
//   decoder = Decoder(varchar, int4)
// )
</code></pre>
<p>Observe the following:</p>
<ul>
  <li>At ① we map the <code>varchar ~ int4</code> decoder directly to Scala type <code>Country</code>, yielding a <code>Decoder[Country]</code>.</li>
  <li>At ② we use our <code>country</code> decoder directly, yielding a <code>Query[Void, Country]</code>.</li>
</ul><div class="callout note "><div class="callout-title">Tip</div>
<p>Because decoders are structural (i.e., they rely only on the position of column values) it can become a maintenance issue when queries and their decoders become separated in code. Try to keep decoders close to the queries that use them.</p></div>
<h3><a href="#mapping-decoder-results-generically" name="mapping-decoder-results-generically" class="anchor"><span class="anchor-link"></span></a>Mapping Decoder Results Generically</h3>
<p>Because <code>Country</code> is a simple case class we can generate the mapping code mechanically. To do this, use <code>gmap</code> and specify the target data type.</p>
<pre class="prettyprint"><code class="language-scala">val country2: Decoder[Country] =
  (varchar ~ int4).gmap[Country]
// country2: Decoder[Country] = Decoder(varchar, int4)
</code></pre>
<p>Even better, instead of constructing a named decoder you can <code>gmap</code> the <code>Query</code> itself.</p>
<pre class="prettyprint"><code class="language-scala">val c2: Query[Void, Country] =
  sql&quot;SELECT name, population FROM country&quot;
    .query(varchar ~ int4)
    .gmap[Country]
// c2: Query[Void, Country] = Query(
//   sql = &quot;SELECT name, population FROM country&quot;,
//   encoder = Encoder(),
//   decoder = Decoder(varchar, int4)
// )
</code></pre>
<h2><a href="#parameterized-query" name="parameterized-query" class="anchor"><span class="anchor-link"></span></a>Parameterized Query</h2>
<p>Now let&rsquo;s add a parameter to the query.</p>
<pre class="prettyprint"><code class="language-scala">val e: Query[String, Country] =
  sql&quot;&quot;&quot;
    SELECT name, population
    FROM   country
    WHERE  name LIKE $varchar
  &quot;&quot;&quot;.query(country)
// e: Query[String, Country] = Query(
//   sql = &quot;&quot;&quot;
//     SELECT name, population
//     FROM   country
//     WHERE  name LIKE $1
//   &quot;&quot;&quot;,
//   encoder = Codec(varchar),
//   decoder = Decoder(varchar, int4)
// )
</code></pre>
<p>Observe that we have interpolated a value called <code>varchar</code>, which has type <code>Encoder[String]</code>.</p>
<p>This means that Postgres will expect an argument of type <code>varchar</code>, which will have Scala type <code>String</code>. The relationship between Postgres types and Scala types is summarized in the reference section <a href="../reference/SchemaTypes.html">Schema Types</a>.</p><div class="callout note "><div class="callout-title">Note</div>
<p>We have already seen <code>varchar</code> used as a row <em>decoder</em> for <code>String</code> and now we&rsquo;re using it as an <em>encoder</em> for <code>String</code>. We can do this because <code>varchar</code> actually has type <code>Codec[String]</code>, which extends both <code>Encoder[String]</code> and <code>Decoder[String]</code>. All type mappings provided by Skunk are codecs and can be used in both positions.</p></div>
<p>The query above is an <em>extended query</em>.</p><div class="callout note "><div class="callout-title">Definition</div>
<p>An <em>extended query</em> is a query with parameters, or a simple query that is executed via the extended query protocol.</p></div>
<p>Postgres provides a <a href="https://www.postgresql.org/docs/10/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY">protocol</a> for executing extended queries which is more involved than simple query protocol. It provides for prepared statements that can be reused with different sets of arguments, and provides cursors which allow results to be paged and streamed.</p>
<p>Here we use the extended query protocol to stream directly to the console using constant space.</p>
<pre class="prettyprint"><code class="language-scala">// assume s: Session[IO]
s.prepare(e).use { ps =&gt;
  ps.stream(&quot;U%&quot;, 64)
    .evalMap(c =&gt; IO.println(c))
    .compile
    .drain
} // IO[Unit]
</code></pre>
<p>Observe that <code>prepare</code> returns a <code>Resource</code> that prepares the statement before use and then frees it on completion. Here we use <a href="https://static.javadoc.io/org.tpolecat/skunk-core_2.12/0.2.3/skunk/PreparedQuery.html#stream" title="skunk.PreparedQuery"><code>PreparedQuery#stream</code></a> to pass our parameter <code>&quot;U%&quot;</code> and then create an <a href="http://fs2.io">fs2</a> stream that fetches rows in blocks of 64 and prints them to the console.</p>
<p>Note that when using <code>Resource</code> and <code>Stream</code> together it is often convenient to express the entire program in terms of <code>Stream</code>.</p>
<pre class="prettyprint"><code class="language-scala">// assume s: Session[IO]
val stream: Stream[IO, Unit] =
  for {
    ps &lt;- Stream.resource(s.prepare(e))
    c  &lt;- ps.stream(&quot;U%&quot;, 64)
    _  &lt;- Stream.eval(IO.println(c))
  } yield ()

stream.compile.drain // IO[Unit]
</code></pre>
<p>This program does the same thing, but perhaps in a more convenient style.</p>
<p><a href="https://static.javadoc.io/org.tpolecat/skunk-core_2.12/0.2.3/skunk/PreparedQuery.html" title="skunk.PreparedQuery"><code>PreparedQuery[A, B]</code></a> provides the following methods for execution. See the Scaladoc for more information.</p>
<table>
  <thead>
    <tr>
      <th>Method </th>
      <th>Return Type </th>
      <th>Notes </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>stream</code> </td>
      <td><code>Stream[F,B]</code> </td>
      <td>All results, as a stream. </td>
    </tr>
    <tr>
      <td><code>option</code> </td>
      <td><code>F[Option[B]]</code> </td>
      <td>Zero or one result, otherwise an error is raised. </td>
    </tr>
    <tr>
      <td><code>unique</code> </td>
      <td><code>F[B]</code> </td>
      <td>Exactly one result, otherwise an error is raised. </td>
    </tr>
    <tr>
      <td><code>cursor</code> </td>
      <td><code>Resource[F,Cursor[F,B]]</code> </td>
      <td>A cursor that returns pages of results. </td>
    </tr>
    <tr>
      <td><code>pipe</code> </td>
      <td><code>Pipe[F, A, B]</code> </td>
      <td>A pipe that executes the query for each input value, concatenating the results. </td>
    </tr>
  </tbody>
</table>
<h2><a href="#multi-parameter-query" name="multi-parameter-query" class="anchor"><span class="anchor-link"></span></a>Multi-Parameter Query</h2>
<p>Multiple parameters work analogously to multiple columns.</p>
<pre class="prettyprint"><code class="language-scala">val f: Query[String ~ Int, Country] =
  sql&quot;&quot;&quot;
    SELECT name, population
    FROM   country
    WHERE  name LIKE $varchar
    AND    population &lt; $int4
  &quot;&quot;&quot;.query(country)
// f: Query[(String, Int), Country] = Query(
//   sql = &quot;&quot;&quot;
//     SELECT name, population
//     FROM   country
//     WHERE  name LIKE $1
//     AND    population &lt; $2
//   &quot;&quot;&quot;,
//   encoder = Codec(varchar, int4),
//   decoder = Decoder(varchar, int4)
// )
</code></pre>
<p>Observe that we have two parameter encoders <code>varchar</code> and <code>int4</code> (in that order), whose corresponding Scala input type is <code>String ~ Int</code>. See the section on <a href="../reference/TwiddleLists.html">twiddle lists</a> for more information.</p>
<pre class="prettyprint"><code class="language-scala">// assume s: Session[IO]
s.prepare(f).use { ps =&gt;
  ps.stream(&quot;U%&quot; ~ 2000000, 64)
    .evalMap(c =&gt; IO.println(c))
    .compile
    .drain
} // IO[Unit]
</code></pre>
<p>And we pass the value <code>&quot;U%&quot; ~ 2000000</code> as our statement argument.</p>
<h2><a href="#summary-of-query-types" name="summary-of-query-types" class="anchor"><span class="anchor-link"></span></a>Summary of Query Types</h2>
<p>The <em>simple query protocol</em> (i.e., <code>Session#execute</code>) is slightly more efficient in terms of message exchange, so use it if:</p>
<ul>
  <li>
  <p>Your query has no parameters; and</p></li>
  <li>
  <p>you are querying for a small number of rows; and</p></li>
  <li>
  <p>you will be using the query only once per session.</p></li>
</ul>
<p>The <em>extend query protocol</em> (i.e., <code>Session#prepare</code>) is more powerful and more general, but requires additional network exchanges. Use it if:</p>
<ul>
  <li>
  <p>Your query has parameters; and/or</p></li>
  <li>
  <p>you are querying for a large or unknown number of rows; and/or</p></li>
  <li>
  <p>you intend to stream the results; and/or</p></li>
  <li>
  <p>you will be using the query more than once per session.</p></li>
</ul>
<h2><a href="#full-example" name="full-example" class="anchor"><span class="anchor-link"></span></a>Full Example</h2>
<p>Here is a complete program listing that demonstrates our knowledge thus far.</p>
<pre class="prettyprint"><code class="language-scala">import cats.effect._
import skunk._
import skunk.implicits._
import skunk.codec.all._
import java.time.OffsetDateTime
import natchez.Trace.Implicits.noop

object QueryExample extends IOApp {

  // a source of sessions
  val session: Resource[IO, Session[IO]] =
    Session.single(
      host     = &quot;localhost&quot;,
      user     = &quot;jimmy&quot;,
      database = &quot;world&quot;,
      password = Some(&quot;banana&quot;)
    )

  // a data model
  case class Country(name: String, code: String, population: Int)

  // a simple query
  val simple: Query[Void, OffsetDateTime] =
    sql&quot;select current_timestamp&quot;.query(timestamptz)

  // an extended query
  val extended: Query[String, Country] =
    sql&quot;&quot;&quot;
      SELECT name, code, population
      FROM   country
      WHERE  name like $text
    &quot;&quot;&quot;.query(varchar ~ bpchar(3) ~ int4)
       .gmap[Country]

  // run our simple query
  def doSimple(s: Session[IO]): IO[Unit] =
    for {
      ts &lt;- s.unique(simple) // we expect exactly one row
      _  &lt;- IO.println(s&quot;timestamp is $ts&quot;)
    } yield ()

  // run our extended query
  def doExtended(s: Session[IO]): IO[Unit] =
    s.prepare(extended).use { ps =&gt;
      ps.stream(&quot;U%&quot;, 32)
        .evalMap(c =&gt; IO.println(c))
        .compile
        .drain
    }

  // our entry point
  def run(args: List[String]): IO[ExitCode] =
    session.use { s =&gt;
      for {
        _ &lt;- doSimple(s)
        _ &lt;- doExtended(s)
      } yield ExitCode.Success
    }

}
</code></pre>
<p>Running this program yields the following.</p>
<pre><code>timestamp is 2022-02-01T17:11:54.968129Z
Country(United Arab Emirates,ARE,2441000)
Country(United Kingdom,GBR,59623400)
Country(Uganda,UGA,21778000)
Country(Ukraine,UKR,50456000)
Country(Uruguay,URY,3337000)
Country(Uzbekistan,UZB,24318000)
Country(United States,USA,278357000)
Country(United States Minor Outlying Islands,UMI,0)
</code></pre>
<h2><a href="#service-oriented-example" name="service-oriented-example" class="anchor"><span class="anchor-link"></span></a>Service-Oriented Example</h2>
<p>In real life a program like <code>QueryExample</code> above will grow complicated an hard to maintain because the database abstractions are out in the open. It&rsquo;s better to define an interface that <em>uses</em> a database session and write your program in terms of that interface. Here is a rewritten version of the program above that demonstrates this pattern.</p>
<pre class="prettyprint"><code class="language-scala">import cats.effect._
import skunk._
import skunk.implicits._
import skunk.codec.all._
import java.time.OffsetDateTime
import natchez.Trace.Implicits.noop
import fs2.Stream
import cats.Applicative

// a data model
case class Country(name: String, code: String, population: Int)

// A service interface.
trait Service[F[_]] {
  def currentTimestamp: F[OffsetDateTime]
  def countriesByName(pat: String): Stream[F, Country]
}

// A companion with a constructor.
object Service {

  private val timestamp: Query[Void, OffsetDateTime] =
    sql&quot;select current_timestamp&quot;.query(timestamptz)

  private val countries: Query[String, Country] =
    sql&quot;&quot;&quot;
      SELECT name, code, population
      FROM   country
      WHERE  name like $text
    &quot;&quot;&quot;.query(varchar ~ bpchar(3) ~ int4)
       .gmap[Country]

  def fromSession[F[_]: Applicative](s: Session[F]): Resource[F, Service[F]] =
    s.prepare(countries).map { pq =&gt;

      // Our service implementation. Note that we are preparing the query on construction, so
      // our service can run it many times without paying the planning cost again.
      new Service[F] {
        def currentTimestamp: F[OffsetDateTime] = s.unique(timestamp)
        def countriesByName(pat: String): Stream[F,Country] = pq.stream(pat, 32)
      }

    }
}


object QueryExample2 extends IOApp {

  // a source of sessions
  val session: Resource[IO, Session[IO]] =
    Session.single(
      host     = &quot;localhost&quot;,
      user     = &quot;jimmy&quot;,
      database = &quot;world&quot;,
      password = Some(&quot;banana&quot;)
    )

  // A source of services
  val service: Resource[IO, Service[IO]] =
    session.flatMap(Service.fromSession(_))

  // our entry point ... there is no indication that we&#39;re using a database at all!
  def run(args: List[String]): IO[ExitCode] =
    service.use { s =&gt;
      for {
        ts &lt;- s.currentTimestamp
        _  &lt;- IO.println(s&quot;timestamp is $ts&quot;)
        _  &lt;- s.countriesByName(&quot;U%&quot;)
               .evalMap(c =&gt; IO.println(c))
               .compile
               .drain
      } yield ExitCode.Success
    }

}
</code></pre>
<p>Running this program yields the same output as above.</p>
<pre><code>timestamp is 2022-02-01T17:11:55.132605Z
Country(United Arab Emirates,ARE,2441000)
Country(United Kingdom,GBR,59623400)
Country(Uganda,UGA,21778000)
Country(Ukraine,UKR,50456000)
Country(Uruguay,URY,3337000)
Country(Uzbekistan,UZB,24318000)
Country(United States,USA,278357000)
Country(United States Minor Outlying Islands,UMI,0)
</code></pre>
<h2><a href="#experiment" name="experiment" class="anchor"><span class="anchor-link"></span></a>Experiment</h2>
<p>Here are some experiments you might want to try.</p>
<ul>
  <li>
  <p>Try to run the <code>extended</code> query via <code>Session#execute</code>, or the <code>simple</code> query via <code>Session#prepare</code>. Note that in the latter case you will need to pass the value <code>Void</code> as an argument.</p></li>
  <li>
  <p>Add/remove/change encoders and decoders. Do various things to make the queries fail. Which kinds of errors are detected at compile-time vs. runtime?</p></li>
  <li>
  <p>Add more fields to <code>Country</code> and more colums to the query; or add more parameters. You will need to consult the <a href="../reference/SchemaTypes.html">Schema Types</a> reference to find the encoders/decoders you need.</p></li>
  <li>
  <p>Experiment with the treatment of nullable columns. You need to add <code>.opt</code> to encoders/decoders (<code>int4.opt</code> for example) to indicate nullability. Keep in mind that for interpolated encoders you&rsquo;ll need to write <code>${int4.opt}</code>.</p></li>
</ul>
<p>For reference, the <code>country</code> table looks like this.</p>
<table>
  <thead>
    <tr>
      <th>Column </th>
      <th>Postgres Type </th>
      <th>Modifiers </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>code </td>
      <td>character(3) </td>
      <td>not null </td>
    </tr>
    <tr>
      <td>name </td>
      <td>character varying </td>
      <td>not null </td>
    </tr>
    <tr>
      <td>continent </td>
      <td>character varying </td>
      <td>not null </td>
    </tr>
    <tr>
      <td>region </td>
      <td>character varying </td>
      <td>not null </td>
    </tr>
    <tr>
      <td>surfacearea </td>
      <td>real </td>
      <td>not null </td>
    </tr>
    <tr>
      <td>indepyear </td>
      <td>smallint </td>
      <td> </td>
    </tr>
    <tr>
      <td>population </td>
      <td>integer </td>
      <td>not null </td>
    </tr>
    <tr>
      <td>lifeexpectancy </td>
      <td>real </td>
      <td> </td>
    </tr>
    <tr>
      <td>gnp </td>
      <td>numeric(10,2) </td>
      <td> </td>
    </tr>
    <tr>
      <td>gnpold </td>
      <td>numeric(10,2) </td>
      <td> </td>
    </tr>
    <tr>
      <td>localname </td>
      <td>character varying </td>
      <td>not null </td>
    </tr>
    <tr>
      <td>governmentform </td>
      <td>character varying </td>
      <td>not null </td>
    </tr>
    <tr>
      <td>headofstate </td>
      <td>character varying </td>
      <td> </td>
    </tr>
    <tr>
      <td>capital </td>
      <td>integer </td>
      <td> </td>
    </tr>
    <tr>
      <td>code2 </td>
      <td>character(2) </td>
      <td>not null </td>
    </tr>
  </tbody>
</table>
<script type="text/javascript" src="../js/link_fix.js"></script>

<div class="source-github">
The source code for this page can be found <a id="source-link" href="https://github.com/tpolecat/skunk/tree/master/modules/docs/target/mdoc/tutorial/Query.md">here</a>.
</div>

<script type="text/javascript">jQuery(function(){sourceUrlFix('https://github.com/tpolecat/skunk/tree/master/modules/docs/target/mdoc/tutorial/Query.md')});</script>

<div class="nav-next">
<p><strong>Next:</strong> <a href="../tutorial/Command.html">Commands</a></p>
</div>
</div>
<div class="large-3 show-for-large column" data-sticky-container>
<nav class="sidebar sticky" data-sticky data-anchor="docs" data-sticky-on="large">
<div class="page-nav">
<div class="nav-title">On this page:</div>
<div class="nav-toc">
<ul>
  <li><a href="../tutorial/Query.html#queries" class="header">Queries</a>
  <ul>
    <li><a href="../tutorial/Query.html#single-column-query" class="header">Single-Column Query</a></li>
    <li><a href="../tutorial/Query.html#multi-column-query" class="header">Multi-Column Query</a></li>
    <li><a href="../tutorial/Query.html#parameterized-query" class="header">Parameterized Query</a></li>
    <li><a href="../tutorial/Query.html#multi-parameter-query" class="header">Multi-Parameter Query</a></li>
    <li><a href="../tutorial/Query.html#summary-of-query-types" class="header">Summary of Query Types</a></li>
    <li><a href="../tutorial/Query.html#full-example" class="header">Full Example</a></li>
    <li><a href="../tutorial/Query.html#service-oriented-example" class="header">Service-Oriented Example</a></li>
    <li><a href="../tutorial/Query.html#experiment" class="header">Experiment</a></li>
  </ul></li>
</ul>
</div>
</div>
</nav>
</div>
</div>

</section>
</div>

</div>

<footer class="site-footer">

<section class="site-footer-nav">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 medium-4 large-3 text-center column">
<div class="nav-links">
<ul>
<!-- <li><a href="https://www.example.com/products/">Products</a> -->
</ul>
</div>
</div>

</div>
</div>
</div>
</section>

<section class="site-footer-base">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 text-center large-9 column">

<!--
<div class="copyright">
<span class="text">&copy; 2022</span>
<a href="https://www.example.com" class="logo">logo</a>
</div>
-->
</div>

</div>
</div>
</div>
</section>
</footer>

</div>
</div>
</div>
</body>

<script type="text/javascript" src="../lib/foundation/dist/foundation.min.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/magellan.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>
<script type="text/javascript">jQuery(function(jq){initOldVersionWarnings(jq, '0.2.3', 'https://github.com/tpolecat/skunk')});</script>


</html>
